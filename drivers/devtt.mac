;**********************************************************************;
;                                                                      ;
;   This file is part of RSX280, a multi-tasking OS for the Z280.      ;
;   Copyright (C) 1985-2020, Hector Peraza.                            ;
;                                                                      ;
;   This program is free software; you can redistribute it and/or      ;
;   modify it under the terms of the GNU General Public License as     ;
;   published by the Free Software Foundation; either version 2 of     ;
;   the License, or (at your option) any later version.                ;
;                                                                      ;
;   This program is distributed in the hope that it will be useful,    ;
;   but WITHOUT ANY WARRANTY; without even the implied warranty of     ;
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      ;
;   GNU General Public License for more details.                       ;
;                                                                      ;
;   You should have received a copy of the GNU General Public License  ;
;   along with this program; if not, write to the Free Software        ;
;   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.          ;
;                                                                      ;
;**********************************************************************;

;----------------------------------------------------------------------;
;                                                                      ;
;   DEV TT: terminal driver (Z280RC version, fully interrupt-driven)   ;
;                                                                      ;
;   Five terminals are supported:                                      ;
;    TT0: = Z280's builtin UART                                        ;
;    TT1: to TT3: = Bill Shen's Quad-Serial board (OX16C954)           ;
;                                                                      ;
;----------------------------------------------------------------------;
;                                                                      ;
; The terminal driver is perhaps the most complex driver of RSX280,    ;
; just as in RSX-11M. In addition to handling task input/output, the   ;
; terminal driver "listens" for user input when idle. If the user      ;
; starts typing at the terminal when no task is waiting for input      ;
; ("unsolicited" input), the characters are placed in a buffer and     ;
; then queued to the CLI assigned to the terminal (normally MCR).      ;
; This is, in fact, the mechanism used by a CLI to receive a command   ;
; (a CLI never attaches to the terminal and never issues a terminal    ;
; read command). In addition, the user can use Ctrl-C to temporarily   ;
; interrupt an input/output operation in progress in order to send     ;
; explicitly a command to the CLI, and the input/output operation is   ;
; resumed afterwards.                                                  ;
;                                                                      ;
;----------------------------------------------------------------------;

	.Z280

	include	Z280.INC

	include	ERRORS.INC
	include	QIO.INC
	include	IOPKT.INC
	include	TCB.INC
	include	PCB.INC
	include	DCB.INC
	include	AST.INC
	include BDRATES.INC
	include	CLICB.INC
	include	SYSCONF.INC

CR	equ	0Dh
LF	equ	0Ah

; OX16C954 addresses as seen from the Z280RC

SER0	equ	0D0h		; channel 0
SER1	equ	0D8h		; channel 1
SER2	equ	0E0h		; channel 2
SER3	equ	0E8h		; channel 3
SERP	equ	0		; quad serial I/O page

; OX16C954 register offsets

_THR	equ	000b		; transmitter holding register
_RHR	equ	000b		; receiver holding register
_IER	equ	001b		; interrupt enable register
_FCR	equ	010b		; FIFO control register
_ISR	equ	010b		; interrupt status register
_LCR	equ	011b		; line control register
_MCR	equ	100b		; modem control register
_LSR	equ	101b		; line status register
_MSR	equ	110b		; modem status register
_SPR	equ	111b		; scratch pad register

; OX16C954 additional standard registers, accessed when LCR:7 = 1

_DLL	equ	000b		; divisor latch register, LSB
_DLM	equ	001b		; divisor latch register, MSB

; OX16C954 650-compatible registers, accessed when LCR is set to 0BFh

_EFR	equ	010b		; enhanced features register
_XON1	equ	100b		; automatic in-band flow control
_XON2	equ	101b		; automatic in-band flow control
_XOFF1	equ	110b		; automatic in-band flow control
_XOFF2	equ	111b		; automatic in-band flow control

; OX16C954 950-specific registers

_ASR	equ	001b		; additional status register
_RFL	equ	011b		; receiver FIFO fill level
_TFL	equ	100b		; transmitter FIFO fill level
_ICR	equ	101b		; indexed control register data

; OX16C954 indexed register set

_ACR	equ	00h		; additional control register
_CPR	equ	01h		; clock prescaler register
_TCR	equ	02h		; times clock register
_CKS	equ	03h		; clock select register
_TTL	equ	04h		; transmitter interrupt trigger level
_RTL	equ	05h		; receiver interrupt trigger level
_FCL	equ	06h		; flow control level
_FCH	equ	07h		; flow control level
_ID1	equ	08h		; device identification register
_ID2	equ	09h		; device identification register
_ID3	equ	0Ah		; device identification register
_REV	equ	0Bh		; 950 core revision
_CSR	equ	0Ch		; channel software reset
_NMR	equ	0Dh		; nine-bit mode register
_MDM	equ	0Eh		; modem disable mask
_RFC	equ	0Fh		; readable FCR
_GDS	equ	10h		; good-data status register
_DMS	equ	11h		; DMA status register
_PIDX	equ	12h		; port index register
_CKA	equ	13h		; clock alteration register

; Device-dependent UCB parameters

UX.BDR	equ	UCBSZ + 0	; default/current baud rate (1 byte)
UX.MOD	equ	UX.BDR + 1	; mode bits (2 bytes)
UX.SBF	equ	UX.MOD + 2	; subfunction code (1 byte)
UX.BFP	equ	UX.SBF + 1	; address of buffer in user space (2 bytes)
UX.BNK	equ	UX.BFP + 2	; user bank (2 bytes)
UX.CNT	equ	UX.BNK + 2	; byte count (2 bytes)
UX.CXF	equ	UX.CNT + 2	; count of bytes transferred (2 bytes)
UX.PRM	equ	UX.CXF + 2	; optional prompt addr in user space (2 bytes)
UX.UBF	equ	UX.PRM + 2	; address of unsolicited input buffer (2 bytes)
UX.UCC	equ	UX.UBF + 2	; unsolicited character count (1 byte)
UX.TMO	equ	UX.UCC + 1	; timeout counter (2 bytes)
UX.TQ	equ	UX.TMO + 2	; address of typeahead queue (2 bytes)
UX.OQ	equ	UX.TQ + 2	; address of output queue (2 bytes)
UX.TXP	equ	UX.OQ + 2	; pointer to transmit buffer (2 bytes)
UX.TXB	equ	UX.TXP + 2	; bank for the pointer above (2 bytes)
UX.TXC	equ	UX.TXB + 2	; count of bytes to transmit (2 bytes)
UX.RXG	equ	UX.TXC + 2	; get receiver char routine addr (2 bytes)
UX.RXE	equ	UX.RXG + 2	; receiver queue check routine addr (2 bytes)
UX.RXC	equ	UX.RXE + 2	; purge receiver queue routine addr (2 bytes)
UX.TXK	equ	UX.RXC + 2	; transmitter restart routine addr (2 bytes)
UX.SSP	equ	UX.TXK + 2	; set serial speed routine address (2 bytes)
UX.AST	equ	UX.SSP + 2	; unsolicited char AST routine addr (2 bytes)

; Device-dependent SCB fields

SX.IFB	equ	SCBSZ + 0	; fork block for input process (7 bytes)
SX.OFB	equ	SX.IFB + 7	; fork block for output process (7 bytes)

; Terminal sub-function bit numbers. These MUST correspond to the TF.xxx
; mask values defined in the QIO.INC file.

TB.AST	equ	0		; attach with AST
TB.RNE	equ	0		; read with no echo
TB.RAL	equ	1		; read all bits (unfiltered)
TB.WAL	equ	1		; write all bits
TB.TMO	equ	2		; read with timeout
TB.WBT	equ	3		; break-through write
TB.CCO	equ	4		; cancel ^O
TB.XOF	equ	5		; send XOFF

; Mode bit numbers

UM.INP	equ	0		; set if processing input
UM.OUT	equ	1		; set if processing output
UM.SIP	equ	2		; saved value of UM.INP during unsol. input
UM.SOP	equ	3		; saved value of UM.OUT during unsol. input
UM.SBY	equ	4		; saved value of US.BSY during unsol. input
UM.UNS	equ	5		; set if processing unsolicited input
UM.OFP	equ	6		; set if output fork process is queued
UM.IFP	equ	7		; set if input fork process is queued

U2.XOF	equ	0		; set if output stopped with ^S
U2.OCC	equ	1		; set if ^C received while in output mode
U2.CTC	equ	2		; set if processing ^C
U2.CTR	equ	3		; set if processing ^R
U2.PRM	equ	4		; set if displaying prompt
U2.CTO	equ	5		; set if output is suppressed by ^O
U2.DEL	equ	6		; set if deleting chars
U2.TMO	equ	7		; set if timeout expired

TTBFSZ	equ	132	;80	; terminal buffer size

; Terminal I/O queue offsets

TQ.MSK	equ	0		; pointer wrap-around mask
TQ.IP	equ	TQ.MSK+1	; input pointer
TQ.OP	equ	TQ.IP+1		; output pointer
TQ.BUF	equ	TQ.OP+1		; start of buffer

; Default terminal chacteristics

DEFTC	equ	(1 SHL TC.SMR) OR (1 SHL TC.SCP) OR (1 SHL TC.ANS)

CCA	equ	0		; set to true to enable ^C processing
				;  *after* current output is done (else
				;  output will be interrupted and then
				;  restored)

DBGTRP	equ	1		; set to true to enable ^T trap to system
				;  debugger-monitor from system console

	extrn	SETHVC,GETPKT,IODONE,QMCR,QAST,$UGETB,$UPUTB
	extrn	LNKFQB,$ALLOC,$FREE,$CLIST

; NOTE: the DCB will be constructed dynamically by the kernel in system
; memory, since the device driver can reside on its own bank or partition.

	cseg

DEVTT::	db	'TT'		; device name
	db	5		; 5 units
	dw	ucbt0		; pointer to list of UCBs
	jp	init		; entry points
	jp	ioreq
	jp	iokill
	jp	tmout

	dseg

ucbt0:	dw	ucbt1		; link to next
	db	0		; unit 0
	db	0		; status byte
	ds	2		; back pointer to DCB (set by kernel)
	dw	scb0		; pointer to SCB
	dw	0		; redirect pointer
	db	(1 SHL UC.ATT)	; control bits
	db	(1 SHL DV.TTY)	; unit characteristics, lo
	db	DEFTC		; terminal chacteristics, hi
	dw	0		; TCB of attached task
	dw	0		; no ACP
	dw	0		; not logged in
	db	S.UNK		; UX.BDR
	ds	2		; UX.MOD
	ds	1		; UX.SBF
	ds	2		; UX.BFP buffer address in user space
	ds	2		; UX.BNK user bank
	ds	2		; UX.CNT byte count (remaining)
	ds	2		; UX.CXF bytes processed
	ds	2		; UX.PRM
	ds	2		; UX.UBF
	ds	1		; UX.UCC
	dw	0		; UX.TMO
	dw	tt0tq		; UX.TQ
	dw	tt0oq		; UX.OQ
	ds	2		; UX.TXP
	ds	2		; UX.TXB
	dw	0		; UX.TXC
	dw	getc0		; UX.RXG
	dw	chkrx0		; UX.RXE
	dw	clrx0		; UX.RXC
	dw	kick0		; UX.TXK
	dw	tt0spd		; UX.SSP
	dw	0		; UX.AST

ucbt1:	dw	ucbt2		; link to next
	db	1		; unit 1
	db	0		; status byte
	ds	2		; back pointer to DCB (set by kernel)
	dw	scb1		; pointer to SCB
	dw	0		; redirect pointer
	db	(1 SHL UC.ATT)	; control bits
	db	(1 SHL DV.TTY)	; unit characteristics, lo
	db	DEFTC		; terminal chacteristics, hi
	dw	0		; TCB of attached task
	dw	0		; no ACP
	dw	0		; not logged in
	db	S.19K2		; UX.BDR
	ds	2		; UX.MOD
	ds	1		; UX.SBF
	ds	2		; UX.BFP buffer address in user space
	ds	2		; UX.BNK user bank
	ds	2		; UX.CNT byte count (remaining)
	ds	2		; UX.CXF bytes processed
	ds	2		; UX.PRM
	ds	2		; UX.UBF
	ds	1		; UX.UCC
	dw	0		; UX.TMO
	dw	tt1tq		; UX.TQ
	dw	tt1oq		; UX.OQ
	ds	2		; UX.TXP
	ds	2		; UX.TXB
	dw	0		; UX.TXC
	dw	getc1		; UX.RXG
	dw	chkrx1		; UX.RXE
	dw	clrx1		; UX.RXC
	dw	kick1		; UX.TXK
	dw	tt1spd		; UX.SSP
	dw	0		; UX.AST

ucbt2:	dw	ucbt3		; link to next
	db	2		; unit 2
	db	0		; status byte
	ds	2		; back pointer to DCB (set by kernel)
	dw	scb2		; pointer to SCB
	dw	0		; redirect pointer
	db	(1 SHL UC.ATT)	; control bits
	db	(1 SHL DV.TTY)	; unit characteristics, lo
	db	DEFTC		; terminal chacteristics, hi
	dw	0		; TCB of attached task
	dw	0		; no ACP
	dw	0		; not logged in
	db	S.19K2		; UX.BDR
	ds	2		; UX.MOD
	ds	1		; UX.SBF
	ds	2		; UX.BFP buffer address in user space
	ds	2		; UX.BNK user bank
	ds	2		; UX.CNT byte count (remaining)
	ds	2		; UX.CXF bytes processed
	ds	2		; UX.PRM
	ds	2		; UX.UBF
	ds	1		; UX.UCC
	dw	0		; UX.TMO
	dw	tt2tq		; UX.TQ
	dw	tt2oq		; UX.OQ
	ds	2		; UX.TXP
	ds	2		; UX.TXB
	dw	0		; UX.TXC
	dw	getc2		; UX.RXG
	dw	chkrx2		; UX.RXE
	dw	clrx2		; UX.RXC
	dw	kick2		; UX.TXK
	dw	tt2spd		; UX.SSP
	dw	0		; UX.AST

ucbt3:	dw	ucbt4		; link to next
	db	3		; unit 3
	db	0		; status byte
	ds	2		; back pointer to DCB (set by kernel)
	dw	scb3		; pointer to SCB
	dw	0		; redirect pointer
	db	(1 SHL UC.ATT)	; control bits
	db	(1 SHL DV.TTY)	; unit characteristics, lo
	db	DEFTC		; terminal chacteristics, hi
	dw	0		; TCB of attached task
	dw	0		; no ACP
	dw	0		; not logged in
	db	S.19K2		; UX.BDR
	ds	2		; UX.MOD
	ds	1		; UX.SBF
	ds	2		; UX.BFP buffer address in user space
	ds	2		; UX.BNK user bank
	ds	2		; UX.CNT byte count (remaining)
	ds	2		; UX.CXF bytes processed
	ds	2		; UX.PRM
	ds	2		; UX.UBF
	ds	1		; UX.UCC
	dw	0		; UX.TMO
	dw	tt3tq		; UX.TQ
	dw	tt3oq		; UX.OQ
	ds	2		; UX.TXP
	ds	2		; UX.TXB
	dw	0		; UX.TXC
	dw	getc3		; UX.RXG
	dw	chkrx3		; UX.RXE
	dw	clrx3		; UX.RXC
	dw	kick3		; UX.TXK
	dw	tt3spd		; UX.SSP
	dw	0		; UX.AST

ucbt4:	dw	0		; link to next
	db	4		; unit 4
	db	0		; status byte
	ds	2		; back pointer to DCB (set by kernel)
	dw	scb4		; pointer to SCB
	dw	0		; redirect pointer
	db	(1 SHL UC.ATT)	; control bits
	db	(1 SHL DV.TTY)	; unit characteristics, lo
	db	DEFTC		; terminal chacteristics, hi
	dw	0		; TCB of attached task
	dw	0		; no ACP
	dw	0		; not logged in
	db	S.19K2		; UX.BDR
	ds	2		; UX.MOD
	ds	1		; UX.SBF
	ds	2		; UX.BFP buffer address in user space
	ds	2		; UX.BNK user bank
	ds	2		; UX.CNT byte count (remaining)
	ds	2		; UX.CXF bytes processed
	ds	2		; UX.PRM
	ds	2		; UX.UBF
	ds	1		; UX.UCC
	dw	0		; UX.TMO
	dw	tt4tq		; UX.TQ
	dw	tt4oq		; UX.OQ
	ds	2		; UX.TXP
	ds	2		; UX.TXB
	dw	0		; UX.TXC
	dw	getc4		; UX.RXG
	dw	chkrx4		; UX.RXE
	dw	clrx4		; UX.RXC
	dw	kick4		; UX.TXK
	dw	tt4spd		; UX.SSP
	dw	0		; UX.AST

scb0:	db	0		; status byte
	dw	0		; head of I/O packet list
	dw	0		; address of current I/O packet
	dw	0		; SX.IFB
	db	0		;  bank
	dw	iproc		;  routine address
	dw	ucbt0		;  context (IY)
	dw	0		; SX.OFB
	db	0		;  bank
	dw	oproc		;  routine address
	dw	ucbt0		;  context (IY)

	IRPC	X,1234
scb&X:	db	0		; status byte
	dw	0		; head of I/O packet list
	dw	0		; address of current I/O packet
	dw	0		; SX.IFB
	db	0		;  bank
	dw	iproc		;  routine address
	dw	ucbt&X		;  context (IY)
	dw	0		; SX.OFB
	db	0		;  bank
	dw	oproc&X		;  routine address
	dw	ucbt&X		;  context (IY)
	ENDM

	cseg

;-----------------------------------------------------------------------

; Initialization.

init:	ld	(ttdcb),de	; store DCB address for timeout routine
	push	ix
	push	iy
	ld	iy,ucbt0
ini0:	res	US.BSY,(iy+U.ST)
	ldw	ix,(iy+U.SCB)	; get SCB address into IX
	ld	hl,0
	ldw	(ix+S.CPKT),hl
	xor	a
	ld	(ix+S.ST),a
	ldw	(iy+UX.MOD),hl	; clear all mode bits
	ld	(iy+UX.UCC),a	; clear unsolicited char count
	ldw	(iy+UX.UBF),hl	; clear user buffer address
	ldw	(iy+UX.PRM),hl	; clear IO.RPR prompt address
	ldw	(iy+UX.TXC),hl	; clear TX count
	ldw	ix,(iy+UX.TQ)
	call	qinit		; init typeahead queue
	ldw	ix,(iy+UX.OQ)
	call	qinit		; init output queue
	ldw	iy,(iy+U.LNK)	; get next UCB into IY
	ld	a,iyh
	or	iyl
	jr	nz,ini0
	call	tt0ini		; hardware-specific init for primary port
	call	ttQini		; hardware-specific init for quad-serial port
	ld	iy,ucbt0
ini1:	ld	a,(iy+UX.BDR)	; get default baud rate
	ld	hl,(iy+UX.SSP)
	call	(hl)		; set serial speed
	ldw	iy,(iy+U.LNK)	; get next UCB into IY
	ld	a,iyh
	or	iyl
	jr	nz,ini1
	pop	iy
	pop	ix
	ret

;-----------------------------------------------------------------------

; I/O request handling, called by the kernel with IY = UCB address.

ioreq:
  IF CCA
	bit	U2.OCC,(iy+UX.MOD+1) ; ^C processing pending?
	jr	z,ioreq1	     ; branch if not
	res	U2.OCC,(iy+UX.MOD+1) ; else clear flag
	call	ctlc0		; and start unsolicited input to MCR
	di
	call	c,kick
	ei
	ret
ioreq1:
  ENDIF
	call	GETPKT		; dequeue I/O packet, return address in IX
	ret	c		; return if unit busy or no work to do
	ldw	bc,(ix+I.TCB)	; get TCB address of requesting task
	ld	hl,T.PCB
	add	hl,bc		; index into PCB field, keep TCB address
	ldw	de,(hl)		;  in BC for SF.SMC
	ld	hl,P.BASE
	add	hl,de		; index into subpartition base
	ldw	hl,(hl)		; get task base page (bank)
	ldw	(iy+UX.BNK),hl	; save it
	ld	de,I.QDB
	add	ix,de		; point to QDB
	ldw	hl,(ix+Q.BUF)	; get buffer address
	ldw	(iy+UX.BFP),hl
	ldw	hl,(ix+Q.LEN)	; get number of bytes to transfer
	ldw	(iy+UX.CNT),hl
	ld	hl,0
	ldw	(iy+UX.CXF),hl	; clear count of bytes processed
	ldw	(iy+UX.TXC),hl	; clear count of bytes to transmit
	ld	a,(ix+Q.SUBF)	; subfunction code
	ld	(iy+UX.SBF),a
	ld	a,(ix+Q.FUNC)	; check function code
	set	US.BSY,(iy+U.ST)
	cp	IO.RLB
	jp	z,ttrlb
	cp	IO.RPR
	jp	z,ttrpr
	cp	IO.WLB
	jp	z,ttwlb
	cp	IO.ATT
	jp	z,ttatt
	cp	IO.DET
	jp	z,ttdet
	cp	SF.GMC
	jp	z,ttgmc
	cp	SF.SMC
	jp	z,ttsmc
	jp	ierr		; invalid function, send error code to
				;  user, free packet and exit via IODONE

;-----------------------------------------------------------------------

; Timeout entry point.

tmout:	ld	iy,ucbt0
	ld	c,0		; timeout active flag
tmo1:	ldw	hl,(iy+UX.TMO)
	ld	a,l		; timeout active for this unit?
	or	h
	jr	z,tmo2		; skip it if not
	dec	hl
	ldw	(iy+UX.TMO),hl
	ld	a,h
	or	l		; counter reached zero?
	jr	nz,tmo3		; branch if not
	set	U2.TMO,(iy+UX.MOD+1) ; set timeout flag
	call	ifpq		; setup deferred char processing
	jr	tmo2
tmo3:	ld	c,1		; set flag to reload timer
tmo2:	ldw	iy,(iy+U.LNK)	; next UCB
	ld	a,iyh
	or	iyl
	jr	nz,tmo1		; loop until all scanned
	ld	a,c
	or	a
	ret	z		; no timeouts pending, return
tmarm:	ld	hl,(ttdcb)
	ld	de,D.TCNT
	add	hl,de
	ld	de,TCKSEC
	ldw	(hl),de		; reload counter
	ret

;-----------------------------------------------------------------------

; Kill outstanding I/O: clear input and output buffers.
; I/O kill point, called with IY = UCB address.

iokill:	call	ttclr		; reset input queue and clear I/O count
	bit	US.BSY,(iy+U.ST)
	ld	bc,E.ABOP
	call	nz,iend1	; end I/O and free packet if terminal was busy
	xor	a
	ret

ttclr:	push	ix
	ldw	ix,(iy+UX.TQ)	; get address of typeahead queue into IX
	call	qinit		; clear it
	ld	hl,0
	ldw	(iy+UX.CNT),hl	; end any I/O packet processing in progress
	ldw	(iy+UX.TXC),hl
	pop	ix
	ret

;-----------------------------------------------------------------------

; Handle 'read with prompt' function.

ttrpr:	ldw	hl,(ix+Q.P3)	     ; get address of prompt string
	ldw	(iy+UX.PRM),hl
	res	U2.CTO,(iy+UX.MOD+1) ; cancel ^O
	ld	a,(iy+UX.CNT)
	or	(iy+UX.CNT+1)
	jp	z,iend
	call	prompt		     ; request display of prompt
	res	UM.OUT,(iy+UX.MOD)
	set	UM.INP,(iy+UX.MOD)   ; set input mode bit
	ldw	hl,(iy+UX.TXK)
	call	c,(hl)		     ; restart transmitter if necessary
	jr	ttr1		     ; continue below

; Handle read function.

ttrlb:	ld	hl,0
	ldw	(iy+UX.PRM),hl
	res	U2.CTO,(iy+UX.MOD+1) ; cancel ^O
	ld	a,(iy+UX.CNT)
	or	(iy+UX.CNT+1)
	jp	z,iend
	res	UM.OUT,(iy+UX.MOD)
	set	UM.INP,(iy+UX.MOD)   ; set input mode bit
ttr1:	di
	call	ifpq		     ; setup deferred character processing
	ei
	ret

;-----------------------------------------------------------------------

; Handle write function.

ttwlb:	ld	a,(iy+U.ATT)
	or	(iy+U.ATT+1)	     ; task attached?
	jr	z,wlb1		     ; branch if not - reset ^O
	bit	TB.CCO,(iy+UX.SBF)   ; cancel ^O?
	jr	z,wlb2		     ; branch if not
wlb1:	res	U2.CTO,(iy+UX.MOD+1)
wlb2:	bit	U2.CTO,(iy+UX.MOD+1) ; ^O active?
	call	nz,supres	     ; suppress output if yes
	ld	a,(iy+UX.CNT)
	or	(iy+UX.CNT+1)
	jp	z,iend		     ; terminate immediately if nothing to send
	res	UM.INP,(iy+UX.MOD)
	set	UM.OUT,(iy+UX.MOD)
	bit	U2.XOF,(iy+UX.MOD+1) ; check XON/XOFF
	ret	nz
	bit	UM.OUT,(iy+UX.MOD)   ; check output mode
	ret	z
	ld	hl,(iy+UX.TXK)
	jp	(hl)		     ; and restart the transmitter

;-----------------------------------------------------------------------

; Handle attach notification

ttatt:	bit	TB.AST,(ix+Q.SUBF)   ; attach with AST?
	jr	z,noast		     ; branch if not
	set	US.AST,(iy+U.ST)     ; else set mode bit in UCB
	ldw	hl,(ix+Q.P1)	     ; get AST routine address
	ldw	(iy+UX.AST),hl	     ; store in UCB
	jp	iend
noast:	res	US.AST,(iy+U.ST)
	jp	iend

; Handle detach notification

ttdet:	res	TC.BIN,(iy+U.CW+1)   ; clear binary mode
	res	U2.CTO,(iy+UX.MOD+1) ; cancel ^O
	res	US.AST,(iy+U.ST)     ; clear AST mode
	ldw	ix,(iy+UX.TQ)	     ; IX = typeahead queue
	di
	call	qinit		     ; flush input
	ei
	jp	iend

;-----------------------------------------------------------------------

; Handle 'get multiple characteristics' function

ttgmc:	ldw	hl,(iy+UX.BFP)	; HL = address of buffer in user space
	ldw	de,(iy+UX.BNK)	; DE = user bank
	ldw	bc,(iy+UX.CNT)	; BC = length in bytes
	srl	b
	rr	c		; length now in words
ttgmc1:	ld	a,b
	or	c
	jp	z,iend		; exit loop when zero
	call	$UGETB		; get byte from user space
	inc	hl
	cp	8		; ensure bit value is in range
	jr	nc,ttgmc4
	push	bc
	ld	b,a
	ld	a,(iy+U.CW+1)	; get terminal characteristics byte
	rlca
	inc	b
ttgmc2:	rrca			; move bit to LSB
	djnz	ttgmc2
	and	01h
ttgmc3:	call	$UPUTB		; store result
	inc	hl
	ldw	bc,(iy+UX.CXF)
	inc	bc
	inc	bc
	ldw	(iy+UX.CXF),bc
	pop	bc
	dec	bc
	jr	ttgmc1

ttgmc4:	sub	8		; TC.SPD?
	jp	nz,ierr
	push	bc
	ld	a,(iy+UX.BDR)	; get speed code
	jr	ttgmc3

;-----------------------------------------------------------------------

; Handle 'set multiple characteristics' function.
; BC still points to TCB of requesting task (see ioreq routine).

ttsmc:	bit	US.PUB,(iy+U.ST); public unit?
	jr	nz,ttsmc0	; yes, anybody can change settings
	ld	hl,T.ATTR
	add	hl,bc
	bit	TA.PRV,(hl)	; privileged task?
	jr	nz,ttsmc0	; branch if yes
	ld	hl,T.TI
	add	hl,bc
	push	iy
	pop	de
	ld	a,(hl)
	cp	e		; else unit (UCB) must match
	ld	bc,E.PRIV
	jp	nz,iend1
	inc	hl
	ld	a,(hl)
	cp	d
	jp	nz,iend1
ttsmc0:	ldw	hl,(iy+UX.BFP)	; HL = address of buffer in user space
	ldw	de,(iy+UX.BNK)	; DE = user bank
	ldw	bc,(iy+UX.CNT)	; BC = length in bytes
	srl	b
	rr	c		; length now in words
ttsmc1:	ld	a,b
	or	c
	jp	z,iend		; exit loop when zero
	call	$UGETB		; get byte from user space
	inc	hl
	cp	8		; ensure bit value is in range
	jr	nc,ttsmc5
	push	bc
	ld	b,a
	ld	a,80h
	inc	b
ttsmc2:	rlca			; obtain bit mask
	djnz	ttsmc2
	ld	c,a
	call	$UGETB		; get bit state
	inc	hl
	or	a		; set or clear?
	ld	a,c
	jr	z,ttsmc3	; branch if clear
	or	(iy+U.CW+1)
	ld	(iy+U.CW+1),a	; set terminal characteristics bit
	jr	ttsmc4
ttsmc3:	cpl
	and	(iy+U.CW+1)
	ld	(iy+U.CW+1),a	; clear terminal characteristics bit
ttsmc4:	ldw	bc,(iy+UX.CXF)
	inc	bc
	inc	bc
	ldw	(iy+UX.CXF),bc
	pop	bc
	dec	bc
	jr	ttsmc1

ttsmc5:	sub	8		; TC.SPD?
	jp	nz,ierr
	push	bc
	call	$UGETB		; get speed code
	push	af
	inc	hl
	push	hl
	ld	hl,(iy+UX.SSP)
	call	(hl)
	pop	hl
	jr	c,ttsmc6
	pop	af
	ld	(iy+UX.BDR),a	; store new speed in UCB
	jr	ttsmc4

ttsmc6:	pop	af
	pop	bc
	jp	ierr

;-----------------------------------------------------------------------

; Characters ^C, ^O, ^S, ^Q and ^X require immediate processing (unless
; terminal is in binary mode). All others are moved to the typeahead
; queue for processing during the next input operation.

iproc:	push	iproc		; push return address
	bit	U2.TMO,(iy+UX.MOD+1)
	jr	z,proc0
	res	U2.TMO,(iy+UX.MOD+1)
	ldw	hl,(iy+UX.RXC)
	call	(hl)		; purge input
	ld	a,15h		; ^U
	ldw	ix,(iy+UX.TQ)	; IX = typeahead queue
	jr	proc7

proc0:	ldw	hl,(iy+UX.RXG)
	call	(hl)		; get RX char
	ldw	ix,(iy+UX.TQ)	; IX = typeahead queue
	jr	c,proc2		; jump if input queue empty

proc7:	ld	c,a

	bit	TC.BIN,(iy+U.CW+1) ; binary mode?
	jr	nz,proc1	   ; branch if yes

	cp	03h		; ^C
	jp	z,ctrlc		; clear typeahead queue, cancel ^S, queue ^C

	cp	13h		; ^S
	jp	z,ctrls

	cp	11h		; ^Q
	jp	z,ctrlq

	cp	0Fh		; ^O
	jp	z,ctrlo

	cp	18h		; ^X
	jp	z,ctrlx

proc1:	di
	call	qput		; store char in typeahead queue
	ei
	ret			; loop until all chars in inp queue processed

; Process char(s) waiting in the typeahead queue. If an input operation
; is in progress, then send the char to the application. Else start an
; unsolicited input to MCR.

; Here with IX = typeahead queue

proc2:	ld	hl,proc5
	ex	(sp),hl		; switch return address
	bit	UM.INP,(iy+UX.MOD) ; input operation in progress?
	jr	nz,proc4	   ; process char if yes
	bit	US.BSY,(iy+U.ST)   ; unit busy (output or r/w chracteristics)?
;;	ret	nz		   ; return if yes
	jr	nz,proc3	   ; branch if yes
	ld	a,(iy+U.ATT)
	or	(iy+U.ATT+1)	   ; task attached?
	jr	z,proc4		   ; process char if not (unsolicited input)
	bit	US.AST,(iy+U.ST)   ; attached with AST?
	jr	nz,proc4	   ; process char if yes
proc3:	call	qpeek
	ret	c
	cp	03h		; ^C?
	ret	nz		; return if not, else process it now
proc4:	di
	call	qget		; get char from typeahead queue
	ei
	ret	c		; return if queue empty
	ld	hl,iproc
	ex	(sp),hl		; switch return address (loop)
	ld	c,a
	call	procch		; process single char
	ret	nc
proc6:	ldw	hl,(iy+UX.TXK)
	jp	(hl)		; restart transmitter if necessary

proc5:	res	UM.IFP,(iy+UX.MOD) ; clear the 'input fork process queued' bit
	ldw	hl,(iy+UX.RXE)	; HL = receiver queue check routine address
	call	(hl)		; note order: check done after clearing UM.IFP
	ret	z		;  bit in order to avoid race condition
	jp	iproc

ctrlo:	bit	UM.INP,(iy+UX.MOD) ; ^O ignored in input mode
	ret	nz
	bit	UM.UNS,(iy+UX.MOD)
	ret	nz
	ld	a,(iy+UX.MOD+1)
	xor	1 SHL U2.CTO	; toggle ^O state
	ld	(iy+UX.MOD+1),a
	bit	U2.CTO,a
	ret	z
supres:	di
	ld	a,(iy+UX.CNT)	; suppress output by skipping any
	add	a,(iy+UX.CXF)	;  remaining chars
	ld	(iy+UX.CXF),a
	ld	a,(iy+UX.CNT+1)
	adc	a,(iy+UX.CXF+1)
	ld	(iy+UX.CXF+1),a
	xor	a
	ld	(iy+UX.CNT),a
	ld	(iy+UX.CNT+1),a
	ei
	ret

ctrls:	set	U2.XOF,(iy+UX.MOD+1) ; stop output
	ret

ctrlq:	res	U2.XOF,(iy+UX.MOD+1) ; resume output
 IF 1
	push	iy
	call	proc6		; restart transmitter
	pop	iy
	ret	nc		; return if there are characters to send
	ld	a,(iy+UX.CNT)	; else check count
	or	(iy+UX.CNT+1)
	ret	nz		; nothing left, return
	di
	call	chkend		; else (possibly) terminate output operation
	ei
	ret
 ELSE
	jp	proc6		; restart transmitter
 ENDIF

ctrlc:	di
	call	qinit		; purge typeahead queue
	ei
	jp	proc1		; queue ^C

ctrlx:	di
	call	qinit		; purge typeahead queue
	ei
	ret

; Process received char. Called in fork processing mode with IY = UCB and
; char in C. Returns with CY set if the transmitter needs to be restarted.

procch:	ldw	ix,(iy+UX.OQ)	; IX = output queue

	call	chktmo

	bit	TC.BIN,(iy+U.CW+1) ; binary mode?
	jr	nz,pcb1		   ; branch if yes

	; filter out certain chars that may have been left in the queue
	; from a previous TC.BIN mode

	ld	a,c
	or	a		; null?
	ret	z
	cp	0Fh		; ^O ?
	ret	z
	cp	13h		; ^S ?
	ret	z
	cp	11h		; ^Q ?
	ret	z

	bit	TC.SMR,(iy+U.CW+1) ; input uppercase conversion enabled?
	call	z,ucase

pcb1:	bit	US.BSY,(iy+U.ST)   ; terminal busy?
	jr	z,pch0		   ; jump if not

	bit	UM.INP,(iy+UX.MOD) ; input mode?
	jr	nz,pch2		   ; jump if yes, process normally

	ldw	hl,(iy+U.ATT)
	ld	a,h
	or	l		; unit attached?
	jr	z,pch3		; jump if not

	bit	US.AST,(iy+U.ST); attached with AST?
	jp	nz,sndast	; jump if yes, queue an AST and return

pch3:	bit	TC.BIN,(iy+U.CW+1) ; binary mode?
	ret	nz		   ; return if yes

	ld	a,c
	cp	03h		; ^C ?
	jp	z,ctlc0		; jump if yes
	or	a
	ret

pch0:	ldw	hl,(iy+U.ATT)
	ld	a,h
	or	l		; unit attached?
	jr	z,pch1		; jump if not, start unsolicited input

	bit	US.AST,(iy+U.ST); attached with AST?
	jp	nz,sndast	; jump if yes, queue an AST

	bit	TC.BIN,(iy+U.CW+1) ; binary mode?
	ret	nz		   ; return if yes

	ld	a,c		; else check char
	cp	03h		; ^C?
	jr	z,pch1		; jump if yes (invoke MCR prompt)

	xor	a		;  (clear CY, do not restart the transmitter)
	ret			; else ignore char, as unsolicited input
				;  to MCR not permitted if device is attached

pch1:	push	bc
	call	unsol		; if terminal not busy, begin unsolicited input
	pop	bc
	ccf
	ret	nc		; if terminal slaved

pch2:	bit	TC.BIN,(iy+U.CW+1) ; binary mode?
	jr	nz,pch4		   ; branch if yes

	ld	a,c
	cp	08h		; backspace?
	jp	z,bkspc

	cp	7Fh		; del?
	jp	z,bkspc

	call	delend

	cp	03h		; ^C ?
	jp	z,ctlc0

	cp	12h		; ^R
	jp	z,ctrlr

	cp	15h		; ^U
	jp	z,ctrlu

pch4:	call	store		; store char in buffer (char in reg C)
	ld	a,c		; get char back in A

	cp	0Dh		; CR
	jp	z,eol

	cp	1Bh		; ESC
	jp	z,esc		; ends line, but does not get echoed

	cp	1Ah		; ^Z
	jp	z,ctrlz

	dec	b		; do not echo char if buffer is full
	ret	nz

	cp	20h		; any other control char?
	jr	nc,echo		; jump if not

ctrl:	ld	b,c
	ld	c,'^'
	call	echo
	ld	a,b
	add	a,40h
	ld	c,a
echo:	or	a
	bit	TB.RNE,(iy+UX.SBF)
	ret	nz		; echo only if TF.RNE not set
	bit	TC.NEC,(iy+U.CW+1)
	ret	nz		; and if in echo mode
	di
	call	qput		; echo it
	scf			; kick transmitter after return
	ei
	ret

ucase:	ld	a,c
	cp	'a'
	ret	c
	cp	'z'+1
	ret	nc
	and	5Fh
	ld	c,a
	ret

ctlc0:	set	U2.CTC,(iy+UX.MOD+1) ; set ^C flag
	bit	UM.UNS,(iy+UX.MOD) ; already processing unsolicited input?
	jr	nz,ccnew	   ; jump if yes

	res	UM.SIP,(iy+UX.MOD)
	res	UM.SOP,(iy+UX.MOD)
	res	UM.SBY,(iy+UX.MOD)
	bit	US.BSY,(iy+U.ST) ; terminal busy?
	jr	z,ccnew		 ; jump if not

	set	UM.SBY,(iy+UX.MOD)

	bit	UM.INP,(iy+UX.MOD) ; input mode?
	jr	nz,ccinp	   ; jump if yes

	bit	UM.OUT,(iy+UX.MOD) ; output mode?
	jr	z,cc1		   ; jump if not

	set	UM.SOP,(iy+UX.MOD) ; else remember previous state
cc1:
  IF CCA
	set	U2.OCC,(iy+UX.MOD+1) ; else set ^C pending flag
	or	a		; and wait for the output operation to finish
	ret
  ELSE
	jr	ccnew
  ENDIF

ccinp:	; remember that there was an input operation in progress, so we can
	; restore task input state after unsolicited input is complete

	set	UM.SIP,(iy+UX.MOD)

ccnew:	res	U2.XOF,(iy+UX.MOD+1) ; clear ^S state
	res	U2.CTO,(iy+UX.MOD+1) ; cancel ^O
	call	unsol		; start unsolicited input
	ccf
	ret	nc		; return if terminal slaved
	call	prompt		; display MCR prompt
	scf			; kick transmitter upon return
	ret

unsol:	bit	TC.SLV,(iy+U.CW+1)
	scf
	ret	nz

	; init MCR input buffer

	ld	(iy+UX.UCC),0	; clear unsolicited character count
	ldw	hl,(iy+UX.UBF)
	ld	a,h
	or	l		; buffer already allocated?
	jr	nz,uns1		; jump if yes
	ld	bc,TTBFSZ
	push	ix
	push	iy
	di
	call	$ALLOC		; else allocate buffer
	ei
	pop	iy
	pop	ix
	ret	c		; return if $ALLOC failed
	ldw	(iy+UX.UBF),hl	; set buffer address in UCB
uns1:	set	US.BSY,(iy+U.ST) ; set busy bit
	ldw	hl,(iy+U.SCB)
	ld	(hl+S.ST),1
	set	UM.UNS,(iy+UX.MOD) ; set unsolicited input flag
	res	UM.OUT,(iy+UX.MOD) ; clear output mode
	set	UM.INP,(iy+UX.MOD) ; set input mode
chktmo:	or	a
	bit	UM.UNS,(iy+UX.MOD)
	ret	z
	ld	hl,120
	ldw	(iy+UX.TMO),hl	; init timeout counter
	call	tmarm		; arm global device timeout
	xor	a
	ret

ctrlr:	call	ctrl		; output ^R
	call	prompt		; display prompt
	jr	nc,ctr1		; jump if no prompt was specified
	set	U2.CTR,(iy+UX.MOD+1) ; else set ^R flag
	scf			; and kick transmitter
	ret

ctr1:	di
	ld	c,CR		; else display just a CR/LF
	call	qput
	ld	c,LF
	call	qput
	ei
	call	prepcr
	scf			; always kick the transmitter to force
	ret			;  output of CR/LF

; Prepare to output whatever we have in the input buffer.
; This routine will be called immediately in response to ^R if no user prompt
; is provided, or by nextch after the prompt has been output.
; Preserves IX.

prepcr:	bit	UM.UNS,(iy+UX.MOD) ; processing unsolicited input?
	jr	nz,ctr2		   ; jump if yes - send UX.UBF
	ldw	bc,(iy+UX.CXF)	; else send user input buffer
	ld	a,b
	or	c		; anything to send?
	ret	z		; return if not
	bit	TB.RNE,(iy+UX.SBF)
	ret	nz		; echo only if TF.RNE not set
	bit	TC.NEC,(iy+U.CW+1)
	ret	nz		; and if in echo mode
	di
	ldw	hl,(iy+UX.BFP)	; else setup pointers and counters
	or	a
	sbc	hl,bc
	ldw	(iy+UX.TXP),hl
	ldw	hl,(iy+UX.BNK)
	ldw	(iy+UX.TXB),hl
	ldw	(iy+UX.TXC),bc
	ei
	scf			; kick transmitter
	ret

ctr2:	ldw	hl,(iy+UX.UBF)	; valid buffer?
	ld	a,h
	or	l
	scf
	ret	z		; return if not
	di
	ldw	(iy+UX.TXP),hl
	ldw	hl,(iy+U.DCB)
	ldw	hl,(hl+D.BANK)	; $SBANK
	ld	h,0		; !!! 8-bit D.BANK
	ldw	(iy+UX.TXB),hl
	ld	l,(iy+UX.UCC)
	ld	h,0
	ldw	(iy+UX.TXC),hl	; set count
	ei
	scf			; kick transmitter
	ret

ctrlu:	call	ctrl
	bit	UM.UNS,(iy+UX.MOD)
	jr	nz,cu1		; end unsolicited input, if active
	call	prompt
	jr	c,rsinp
	di
	ld	c,CR
	call	qput
	ld	c,LF
	call	qput
	ei
rsinp:	ldw	bc,(iy+UX.CXF)
	ld	a,b
	or	c
	scf
	ret	z
	di
	ldw	hl,(iy+UX.BFP)
	xor	a
	sbc	hl,bc
	ldw	(iy+UX.BFP),hl	; reset buffer start address
	ldw	hl,(iy+UX.CNT)
	add	hl,bc
	ldw	(iy+UX.CNT),hl	; reset number of bytes to transfer
	ld	hl,0
	ldw	(iy+UX.CXF),hl	; clear processed char count
	ei
	scf
	ret

cu0:	ld	c,15h
	call	ctrl
cu1:	xor	a
	ld	(iy+UX.UCC),a
	ld	c,0Dh
	call	stoubf
	jp	eol

bkspc:	bit	UM.UNS,(iy+UX.MOD)
	jr	nz,bs1		; jump if processing unsolicited input
	ldw	hl,(iy+UX.CXF)
	ld	a,h
	or	l
	scf
	ret	z
	dec	hl
	ldw	(iy+UX.CXF),hl
	ldw	hl,(iy+UX.BFP)
	dec	hl
	ldw	(iy+UX.BFP),hl
	incw	(iy+UX.CNT)
	ldw	de,(iy+UX.BNK)
	call	$UGETB
	jr	bs2

bs1:	ld	a,(iy+UX.UCC)
	or	a
	ret	z
	dec	a
	ld	(iy+UX.UCC),a
	ld	e,a
	ldw	hl,(iy+UX.UBF)	; get address of unsolicited input buffer
	ld	a,h
	or	l		; valid?
	ret	z		; return if not
	ld	d,0
	add	hl,de		; index into buffer
	ld	a,(hl)
bs2:	bit	TC.SCP,(iy+U.CW+1) ; scope mode?
	jr	z,bs4		   ; branch if not
	cp	20h		; deleting control char?
	call	c,bs3		; erase it twice from screen if yes
bs3:	or	a
	bit	TB.RNE,(iy+UX.SBF)
	ret	nz		; erase only if reading with echo
	bit	TC.NEC,(iy+U.CW+1)
	ret	nz		; and if in echo mode
	ld	hl,bstr
	ld	b,bslen
	call	qstr
	scf			; restart transmitter
	ret

bs4:	call	delst
	ld	c,a
	cp	20h
	jp	c,ctrl
	jp	echo

delst:	bit	U2.DEL,(iy+UX.MOD+1)
	ret	nz
	set	U2.DEL,(iy+UX.MOD+1)
	jr	dele

delend:	bit	U2.DEL,(iy+UX.MOD+1)
	ret	z
	res	U2.DEL,(iy+UX.MOD+1)
dele:	push	af
	push	bc
	ld	c,'/'
	call	echo
	pop	bc
	pop	af
	ret

bstr:	db	8,' ',8
bslen	equ	$ - bstr

; TODO: it may happen that after a ^R, CR or ^Z the buffer is processed and
; freed before the transmitter had time to display everything (especially
; after a ^R). To overcome that race condition we could set a flag here and
; only call iend/uend in nextch when the transmitter finishes sending.

ctrlz:	call	ctrl
	ld	c,0Dh
eol:	di
	call	qput		; echo CR
	ei
esc:	res	U2.CTO,(iy+UX.MOD+1) ; cancel ^O
	bit	UM.UNS,(iy+UX.MOD) ; processing unsolicited input?
	jr	nz,ueol		   ; jump if yes
	push	iy
	call	iend
	pop	iy
	scf
	ret

ueol:	ldw	hl,(iy+UX.UBF)	; get address of unsolicited input buffer
	ld	a,h
	or	l		; valid?
	ret	z		; return if not
	ld	e,(iy+UX.UCC)	; get character count into DE
	ld	d,0
	push	iy
	push	hl
	call	QMCR		; send command to MCR, IY = UCB
	pop	hl
	ld	de,TTBFSZ
	di
	call	$FREE		; free buffer
	ei
	pop	iy
	xor	a
	ld	(iy+UX.UBF),a
	ld	(iy+UX.UBF+1),a

	call	ioreq		;;; in case we interrupted something
				;;; (needed since ueol does not call IODONE!)

	call	uend		; clear unsol. input flag, restore prev mode
	scf			; restart transmitter
	ret

; Store char (in reg C) into task's buffer or unsolicited input buffer
; according to current mode. Returns B=1 if char stored, or B=0 if
; buffer is full.

store:	ld	b,0
	bit	UM.UNS,(iy+UX.MOD) ; processing unsolicited input?
	jr	nz,stoubf	   ; jump if yes

	ldw	hl,(iy+U.SCB)
	ld	de,S.CPKT
	add	hl,de
	ld	a,(hl)		; check for a valid I/O packet
	inc	hl
	or	(hl)
	ret	z		; else ignore input

	ldw	hl,(iy+UX.CNT)	; check remaining count
	ld	a,h
	or	l
	jr	z,st1

	ldw	hl,(iy+UX.BFP)	; get user buffer address into HL
	ldw	de,(iy+UX.BNK)	; and bank into DE
	ld	a,c
	call	$UPUTB		; store char in user space
	inc	hl
	ldw	(iy+UX.BFP),hl	; store new buffer pointer
	incw	(iy+UX.CXF)	; increment count of bytes processed
	ldw	hl,(iy+UX.CNT)	; decrement remaining count
	dec	hl
	ldw	(iy+UX.CNT),hl
	ld	a,h
	or	l
	ld	a,c
st1:	ld	c,1Bh		; force end of input if buffer is full
	ret	z
	ld	b,1
	ld	c,a
	ret

stoubf:	ldw	hl,(iy+UX.UBF)
	ld	a,h		; buffer should have been already allocated
	or	l
	ret	z		; else error - ignore char
	ld	a,(iy+UX.UCC)
	ld	e,a		; get UX.UCC value into E
	ld	d,0
	add	hl,de		; index into buffer
	ld	(hl),c		; store char in MCR buffer
	inc	a
	cp	TTBFSZ
	jp	nc,cu0
	ld	(iy+UX.UCC),a
	ld	b,1
	ret

; clear unsolicited input flag and restore any previous input mode.

uend:	res	UM.UNS,(iy+UX.MOD)
	res	U2.CTC,(iy+UX.MOD+1)
	res	UM.INP,(iy+UX.MOD)
	res	US.BSY,(iy+U.ST)
	ld	hl,0
	ldw	(iy+UX.TMO),hl	; clear timeout counter
	ldw	de,(iy+U.SCB)	; get SCB address into DE
	ld	hl,S.CPKT
	add	hl,de
	ld	a,(hl)		; check for packet still present
	inc	hl
	or	(hl)
	jr	nz,ucl0		; jump if set, need to restore state
	ld	hl,S.ST
	add	hl,de
	ld	(hl),0		; else clear status byte in SCB
ucl0:	bit	UM.SBY,(iy+UX.MOD) ; do we have to restore previous state?
	ret	z		   ; return if not
	set	US.BSY,(iy+U.ST)
	res	UM.SBY,(iy+UX.MOD)
	bit	UM.SIP,(iy+UX.MOD) ; previous state was input?
	jr	nz,ucl1		   ; branch if yes
	bit	UM.SOP,(iy+UX.MOD) ; was it output?
	ret	z		   ; return if not
	res	UM.SOP,(iy+UX.MOD)
	set	UM.OUT,(iy+UX.MOD)
	jr	ucl2
ucl1:	res	UM.SIP,(iy+UX.MOD)
	set	UM.INP,(iy+UX.MOD)
	call	rsinp		; reset input state
	call	prompt		; redisplay prompt if necessary
	ret	nc
ucl2:	ldw	hl,(iy+UX.TXK)
	jp	(hl)		; restart the transmitter

; setup display of prompt

prompt:	bit	UM.UNS,(iy+UX.MOD) ; processing unsolicited input?
	jr	z,pruser	; jump if not - display user prompt
	ld	b,1		; get ^C prompt
	bit	U2.CTC,(iy+UX.MOD+1) ; processing ^C?
	jr	nz,prm1		; jump if yes
	dec	b		; else get default prompt
prm1:	call	cliprm		; get prompt from CLICB
	ex	de,hl
	ldw	hl,(iy+U.DCB)
	ldw	hl,(hl+D.BANK)	; $SBANK
	ld	h,0		; !!! 8-bit D.BANK
	ex	de,hl
	jr	prm2
pruser:	ldw	hl,(iy+UX.PRM)	; did user specify a prompt?
	ld	a,h
	or	l
	ret	z		; return with CY clear if not
	ldw	de,(iy+UX.BNK)	; task bank
prm2:	ldw	(iy+UX.TXP),hl	; else set address of string to display
	ldw	(iy+UX.TXB),de	; set bank
	set	U2.PRM,(iy+UX.MOD+1) ; set 'display prompt' bit
	scf			; and return with CY set
	ret

; send char in C to task via AST

sndast:	ldw	ix,(iy+U.ATT)	; get TCB addr of attached task into IX
	ld	l,c		; arg lo = char
	ld	h,(iy+U.UNIT)	; arg hi = unit number
	push	hl
	ld	hl,0
	add	hl,sp		; pointer to AST args
	ldw	de,(iy+UX.AST)	; get AST routine address
	ld	c,2		; arg length
	ld	a,AST.UC	; AST type
	push	iy
	call	QAST		; queue AST to task
	pop	iy
	pop	hl
	xor	a		; ignore errors
	ret

;-----------------------------------------------------------------------

; This is called from kernel in fork processing mode.

iend:	ld	bc,0		; success code
	jr	iend1
ierr:	ld	bc,E.BADOP	; error code = invalid operation
iend1:	push	bc
	di
	res	UM.INP,(iy+UX.MOD) ; clear input mode bit
	res	UM.OUT,(iy+UX.MOD) ; clear output mode bit
	res	UM.SIP,(iy+UX.MOD)	;??? just
	res	UM.SOP,(iy+UX.MOD)	;???  in
	res	UM.SBY,(iy+UX.MOD)	;??? case
	res	US.BSY,(iy+U.ST)   ; clear busy bit
 IF 1
	; need this to restart input processing after *output* operation
	call	ifpq		; schedule input fork process
 ENDIF
	ei
	pop	bc		; error/success code in BC
	ldw	de,(iy+UX.CXF)	; transfer count in DE
	jp	IODONE		; store result and end operation

; Get next char to send, either from local output queue or from requesting
; task's buffer.
; Called with IY = UCB. Returns CY set if no more chars to send.
; Do not call from the interrupt routine.

FF4	equ	1		; test code - translate FF to 4xLF

nextch:
  IF 0
	bit	U2.XOF,(iy+UX.MOD+1)
	scf
	ret	nz
  ENDIF
	ldw	ix,(iy+UX.OQ)	; handle pending chars in output queue first
	call	qget
	ret	nc
	bit	U2.PRM,(iy+UX.MOD+1) ; displaying prompt?
	jr	z,nxch0		     ; jump if not
	call	nxuch		; else fetch byte from prompt in user space
	or	a		; end of string?
  IF FF4
	jr	nz,nxch4	; branch if not
  ELSE
	ret	nz		; return if not
  ENDIF
	res	U2.PRM,(iy+UX.MOD+1) ; else clear 'display prompt' bit
	bit	U2.CTR,(iy+UX.MOD+1) ; ^R redisplay of prompt?
	scf
	ret	z		; return if not
	call	prepcr		; else prepare to output input buffer
	jr	c,nxch0		; continue if something to send
	res	U2.CTR,(iy+UX.MOD+1) ; otherwise clear ^R bit
	scf
	ret			; and return
nxch0:	ldw	hl,(iy+UX.TXC)	; check UX.TXC
	ld	a,h
	or	l		; anything to send?
	jr	z,nxch1		; jump if not
	dec	hl
	ldw	(iy+UX.TXC),hl
	call	nxuch		; else get byte from task space
	or	a		; clear CY
	bit	U2.CTR,(iy+UX.MOD+1) ; ^R redisplay of buffer?
  IF FF4
	jr	nz,nxch2	     ; branch if yes
nxch4:	cp	0Ch		; form-feed?
	jr	nz,nxch3	; return if not
	ld	c,0Ah		; else convert it to four line-feeds
	ld	b,4-1
	ldw	ix,(iy+UX.OQ)
ff:	call	qput
	djnz	ff
	ld	a,c
nxch3:	or	a
	ret
  ELSE
	ret	z		     ; return unmodified char if not
  ENDIF
nxch2:	cp	20h		; control char?
	ret	nc		; return if not
	add	a,40h		; else echo it as ^x
	ld	c,a
	call	qput		; note IX still = UX.OQ from above
	ld	a,'^'
	or	a
	ret
nxch1:	res	U2.CTR,(iy+UX.MOD+1) ; clear ^R bit
  IF 0
	bit	UM.UNS,(iy+UX.MOD) ; check unsolicited input flag
	scf			   ; return if set
	ret	nz
  ELSE
	bit	US.BSY,(iy+U.ST) ; busy?
	scf
	ret	z		 ; return if not
  ENDIF
	bit	UM.OUT,(iy+UX.MOD) ; output mode?
	scf			   ; return if not
	ret	z
	ldw	ix,(iy+U.SCB)
	ld	a,(ix+S.CPKT)	; check current packet address
	or	(ix+S.CPKT+1)	; anything being processed?
	scf			; return if not
	ret	z
	ldw	hl,(iy+UX.CNT)	; check byte counter
	ld	a,h
	or	l
	scf
	ret	z		; nothing else to send, return with CY set
	dec	hl		; decrement byte counter
	ldw	(iy+UX.CNT),hl	; save value back
	incw	(iy+UX.CXF)	; increment count of bytes processed
	ldw	hl,(iy+UX.BFP)	; get user buffer address into HL
	ldw	de,(iy+UX.BNK)	; and bank into DE
	call	$UGETB		; get char from user space
	inc	hl
	ldw	(iy+UX.BFP),hl	; save next address
  IF FF4
	jr	nxch4
  ELSE
	or	a
	ret
  ENDIF

nxuch:	ldw	hl,(iy+UX.TXP)
	ldw	de,(iy+UX.TXB)
	call	$UGETB		; get byte from task space
	inc	hl
	ldw	(iy+UX.TXP),hl
	ret

; Check for end of output operation

chkend:	bit	US.BSY,(iy+U.ST)   ; check busy flag
	ret	z		   ; return if not set
  IF 1
	bit	U2.XOF,(iy+UX.MOD+1)
	ret	nz
  ENDIF
	bit	UM.OUT,(iy+UX.MOD) ; check output flag
	ret	z		   ; return if not set
	jp	iend		   ; else end output operation

; Schedule output fork block process. Call with interrupts disabled.

ofpq:	bit	UM.OFP,(iy+UX.MOD) ; fork process already scheduled?
	ret	nz		   ; return if yes
	set	UM.OFP,(iy+UX.MOD) ; else set flag
	ldw	ix,(iy+U.SCB)	   ; get SCB address into HL
	ld	de,SX.OFB
	add	ix,de		   ; point to output fork block process 
	jp	LNKFQB		   ; queue fork block and return

; Schedule input fork block process. Call with interrupts disabled.

ifpq:	bit	UM.IFP,(iy+UX.MOD) ; fork process already queued?
	ret	nz		   ; return if yes
	set	UM.IFP,(iy+UX.MOD) ; else set flag
	ldw	ix,(iy+U.SCB)	   ; get SCB address
	ld	de,SX.IFB
	add	ix,de		   ; point to input fork block process 
	jp	LNKFQB		   ; queue fork block and return

;-----------------------------------------------------------------------
; Hardware-dependent section
;-----------------------------------------------------------------------

;***********************************************************************
;*                                                                     *
;*      Unit 0 routines                                                *
;*                                                                     *
;***********************************************************************

; Init TT0:

tt0ini:	ld	ix,tt0iq
	call	qinit		; init software receiver queue
	ld	ix,tt0xq
	call	qinit		; init software transmitter queue

	ld	de,TT0RX
	ld	hl,(ucbt0+U.DCB)
	ld	a,(hl+D.BANK)
	ld	c,a
	ld	a,13		; RX uses interrupt vector 13
	call	SETHVC

	ld	de,TT0TX
	ld	hl,(ucbt0+U.DCB)
	ld	a,(hl+D.BANK)
	ld	c,a
	ld	a,14		; TX uses interrupt vector 14
	call	SETHVC

  if 0
	iopage	CTP
	ld	a,10001000b	; CT1: continuous, timer, output
	out	(CR1),a
	ld	a,11100000b	; enable CT1
	out	(CS1),a
	ld	a,S.115K2
	call	tt0spd
  endif

	iopage	UARTP
	ld	a,10000001b	; enable TX, but disable interrupts
	out	(TCS),a
	ld	a,11000000b	; enable RX and RX interrupts
	out	(RCS),a
  if 0
	ld	a,11001010b	; 8 data bits, no parity, clk rate x16
	out	(UCR),a
  endif
	in	a,(RDR)		; discard any spurious char
	in	a,(RDR)
	ret

; Set serial speed, A = baud rate code

tt0spd:	dec	a		; skip S.0
	ret	m
	cp	S.115K2		; ensure within allowed range
	ccf
	ret	c
	iopage	CTP
	ld	hl,brdiv	; get divisor table address
	add	a,a
	add	hl,a		; index into table (A is still positive)
	ld	hl,(hl)		; fetch value
	dec	hl		; -1 for counter
	ld	c,TC1
	outw	(c),hl
  if 1
	ld	a,10001000b	; CT1: continuous, timer, output
	out	(CR1),a
	ld	a,11100000b	; enable CT1
	out	(CS1),a
  endif
	iopage	UARTP
  if 0
	ld	a,11001010b	; 8 data bits, no parity, clk rate x16
	out	(UCR),a
  else
	in	a,(UCR)
	set	3,a		; select CT1 as clock source
	out	(UCR),a
  endif
	in	a,(RDR)		; discard any spurious char
	in	a,(RDR)
	xor	a		; success
	ret	

;-----------------------------------------------------------------------

; TT0 transmitter restart routine.

kick0:	call	refill		; refill output queue
	iopage	UARTP
	in	a,(TCS)
	set	6,a		; (re)enable TX interrupts
	out	(TCS),a
	in	a,(TCS)
	and	01h		; check transmitter buffer empty bit
	ret	z
	di
	ld	ix,tt0xq
	call	qget		; anything in transmitter queue?
	ei
	jr	c,k0		; branch if not
	out	(TDR),a		; else send char to restart transmitter
	ret			; and return
k0:	in	a,(TCS)
	res	6,a		; disable TX interrupts
	out	(TCS),a
	ret

; TT0 output fork process: refill queue and restart transmitter or end output
; accordingly.

oproc:	res	UM.OFP,(iy+UX.MOD) ; clear 'output fork process pending' flag
	call	refill		; refill output queue
	di
	call	qsize		; anything in output queue?
	ei
	jp	z,chkend	; end output operation if not
	ld	hl,(iy+UX.TXK)
	jp	(hl)		; else restart transmitter

; Refill transmitter queue

refill:	ld	ix,tt0xq	; IX = transmitter queue
r1:	di
	call	qsize
	ei
	cp	(ix+TQ.MSK)	; mask = queue size - 1
	ret	nc		; return if queue is full
	push	ix
	call	nextch		; anything (else) to send?
	pop	ix
	ret	c		; return if not
	ld	c,a
	di
	call	qput		; else store char in queue
	ei
	jr	r1		; and loop to process next

; TT0 get RX character

getc0:	ld	ix,tt0iq	; IX = input queue
	di
	call	qget		; get char from TT0 input queue
	ei
	ret

; Check RX input queue, returns Z if queue is empty

chkrx0:	ld	ix,tt0iq
	di
	call	qempty
	ei
	ret

; Purge RX queue

clrx0:	ld	ix,tt0iq
	di
	call	qinit
	ei
	ret

;-----------------------------------------------------------------------

; TT0 interrupt handling routines.

; Z280 transmitter interrupt
; Interrupts are already disabled by the interrupt stub in common memory.
; AF, HL, DE, BC and the I/O page also have been saved.

TT0TX:	push	ix
	push	iy
	iopage	UARTP
	ld	iy,ucbt0
	bit	U2.XOF,(iy+UX.MOD+1)
	jr	nz,tx1		; stop output if XOFF bit is set
	ld	ix,tt0xq
	call	qget		; get next char to send
	jr	c,tx1		; jump if no more chars
	out	(TDR),a		; else send char
	call	qsize
	cp	16		; time to refill queue?
	jr	c,tx2		; yes
	jr	tx3		; no
tx1:	in	a,(TCS)
	res	6,a		; disable further ESCC TX interrupts
	out	(TCS),a		;  or TX will keep interrupting forever
tx2:	call	ofpq		; setup process to refill queue
tx3:	pop	iy
	pop	ix
	ret

; Z280 receiver interrupt

TT0RX:	push	ix
	push	iy
	iopage	UARTP
	ld	iy,ucbt0
rx1:	in	a,(RDR)		; fetch char
	ld	c,a
  IF DBGTRP
	cp	14h		; ^T = debug trap
	call	z,$DBTRP##	; enter debugger with ints disabled
  ENDIF
	ld	ix,tt0iq
	call	qput		; save it in input queue
	in	a,(RCS)		; check if more available
	bit	4,a
	jr	nz,rx1		; loop until rx buffer empty
	call	ifpq		; fork input process
	pop	iy
	pop	ix
	ret

;***********************************************************************
;*                                                                     *
;*      Unit 1..4 routines                                             *
;*                                                                     *
;***********************************************************************

; Init TT1..TT4 (OX16C954 quad-serial)

ttQini:	iopage	SERP
	call	ident		; read ID
	jr	c,iniq3		; branch if quad-serial board not in system

	ld	de,TTQINT
	ld	hl,(ucbt1+U.DCB)
	ld	a,(hl+D.BANK)
	ld	c,a
	ld	a,3		; OX16C954 uses interrupt vector 3 (INTB)
	call	SETHVC

	ld	e,SER0		; begin with channel 0
	ld	d,4		; 4 channels to setup
iniq1:	ld	hl,initbl	; HL = addr of initialization table
	ld	b,tblen		; B = table length
iniq2:	ld	a,(hl)		; get register address
	add	a,e		; add channel base address
	ld	c,a		; port address in reg C
	inc	hl
	ld	a,(hl)		; get value
	out	(c),a		; set register
	inc	hl
	djnz	iniq2		; loop until all registers set

;;	ld	a,S.19K2
;;	call	ttQspd		; set baud rate
;;	ld	c,e
;;	in	a,(c)		; flush any spurious char
	ld	a,e
	add	a,SER1-SER0	; get address of next channel
	ld	e,a
	dec	d		; all channels initialized?
	jr	nz,iniq1	; loop if not
	ret

; OX16C954 chip not detected, set units 1..4 offline

iniq3:	ld	iy,ucbt1
	ld	b,4
iniq4:	set	US.OFL,(iy+U.ST) ; set unit off-line
	ldw	iy,(iy+U.LNK)
	djnz	iniq4
	ret	

; Check OX16C954 presence by reading the ID registers

ident:	xor	a
	out	(SER0+_LCR),a
	out	(SER0+_SPR),a	; select ACR
	ld	a,01000000b
	out	(SER0+_ICR),a	; enable indexed register read
	ld	hl,id
	ld	e,_ID1		; read _ID1.._ID3 + _REV
	ld	b,4		; thus 4 registers
id1:	ld	a,e
	out	(SER0+_SPR),a	; select register
	in	a,(SER0+_ICR)	; read value
	cp	(hl)		; compare with expected
	scf
	jr	nz,id2		; error if not same
	inc	hl
	inc	e
	djnz	id1
	xor	a
id2:	push	af
	xor	a
	out	(SER0+_SPR),a	; select ACR
	ld	a,00000000b
	out	(SER0+_ICR),a	; enable access to standard regs again
	pop	af
	ret

id:	db	16h,0C9h,54h,04h

; Set serial speed, A = baud rate code

tt1spd:	ld	e,SER0
	jr	tt4s1

tt2spd:	ld	e,SER1
	jr	tt4s1

tt3spd:	ld	e,SER2
	jr	tt4s1

tt4spd:	ld	e,SER3
tt4s1:	iopage	SERP
	; continue below

; Set serial speed, E = channel base address, A = baud rate code

ttQspd:	dec	a		; skip S.0
	ret	m
	cp	S.115K2		; ensure within allowed range
	ccf
	ret	c
	ld	hl,brdiv	; get divisor table address
	add	a,a
	add	hl,a		; index into table (A is still positive)
	ld	a,_LCR		; select LCR register
	add	a,e
	ld	c,a
	ld	b,a		; remember LCR address
	in	a,(c)
	set	7,a		; enable access to divisor
	out	(c),a
	ld	a,_DLL		; select divisor register
	add	a,e
	ld	c,a
	ld	a,(hl)
	out	(c),a
	inc	hl
	inc	c		; _DLM
	ld	a,(hl)
	out	(c),a
	ld	c,b		; select again LCR register
	in	a,(c)
	res	7,a		; disable access to divisor
	out	(c),a
	ld	c,e
	in	a,(c)		; flush any spurious char
	xor	a		; success
	ret	

; Baud rate divisors for clk rate = 7.3728MHz / 2 / 16 = 230400 Hz

brdiv:	dw	4608		; S.50
	dw	3072		; S.75
	dw	2095		; S.110		; 2094.55
	dw	1713		; S.134
	dw	1536		; S.150
	dw	1152		; S.200
	dw	768		; S.300
	dw	384		; S.600
	dw	192		; S.1200
	dw	128		; S.1800
	dw	115		; S.2000	; 115.2
	dw	96		; S.2400
	dw	64		; S.3600
	dw	48		; S.4800
	dw	32		; S.7200
	dw	24		; S.9600
	dw	16		; S.14K4
	dw	12		; S.19K2
	dw	8		; S.28K8
	dw	6		; S.38K4
	dw	4		; S.57K6
	dw	3		; S.76K8
	dw	2		; S.115K2

initbl:	db	_LCR,	00000000b	; ensure LCR is not 0BFh
	db	_SPR,	_CSR		; select CSR register
	db	_ICR,	0		;  reset UART channel, selects 450 mode

	db	_LCR,	0BFh		; enable access to 650-mode registers
	db	_EFR,	00010000b	; set enhanced mode

 if 0
	db	_LCR,	00001011b	; 8-O-1
 else
	db	_LCR,	00000011b	; 8-N-1
 endif
	db	_SPR,	_TCR		; select TCR register
	db	_ICR,	0		;  zero times clock reg (make SC = 16)

	db	_SPR,	_CPR		; select CPR register
	db	_ICR,	00010000b	; M=2, N=0 (divide by 2)

	db	_MCR,	10001011b	; enable prescaler, enable INT pin,
					;  DTR and RTS active

	db	_FCR,	00000001b	; enable FIFO, RX threshold level = 1

	db	_IER,	00000001b	; enable RX interrupts

tblen	equ	($-initbl)/2

;-----------------------------------------------------------------------

; TT1..TT4 transmitter restart routines.

kick1:	iopage	SERP
	in	a,(SER0+_LSR)
	bit	5,a		; check transmitter empty bit
	ret	z		; still transmitting, return
	call	refil1		; else refill transmitter FIFO
	ret	z		; return if nothing sent
	in	a,(SER0+_IER)
	set	1,a		; else (re)enable TX interrupts
	out	(SER0+_IER),a
	ret

kick2:	iopage	SERP
	in	a,(SER1+_LSR)
	bit	5,a		; check transmitter empty bit
	ret	z		; still transmitting, return
	call	refil2		; else refill transmitter FIFO
	ret	z		; return if nothing sent
	in	a,(SER1+_IER)
	set	1,a		; else (re)enable TX interrupts
	out	(SER1+_IER),a
	ret

kick3:	iopage	SERP
	in	a,(SER2+_LSR)
	bit	5,a		; check transmitter empty bit
	ret	z		; still transmitting, return
	call	refil3		; else refill transmitter FIFO
	ret	z		; return if nothing sent
	in	a,(SER2+_IER)
	set	1,a		; else (re)enable TX interrupts
	out	(SER2+_IER),a
	ret

kick4:	iopage	SERP
	in	a,(SER3+_LSR)
	bit	5,a		; check transmitter empty bit
	ret	z		; still transmitting, return
	call	refil4		; else refill transmitter FIFO
	ret	z		; return if nothing sent
	in	a,(SER3+_IER)
	set	1,a		; else (re)enable TX interrupts
	out	(SER3+_IER),a
	ret

; TT1..4 output fork process: refill transmitter FIFO.

oproc1:	iopage	SERP
	res	UM.OFP,(iy+UX.MOD) ; clear 'output fork process pending' flag
	bit	U2.XOF,(iy+UX.MOD+1)
	ret	nz		; return if XOFF bit is set
	call	refil1		; refill transmitter FIFO
	jp	z,chkend	; end output operation if nothing sent
	in	a,(SER0+_IER)
	set	1,a		; (re)enable TX interrupts
	out	(SER0+_IER),a
	ret

refil1:	ld	b,16
	ld	c,0
rf11:	push	bc
	call	nextch		; anything (else) to send?
	pop	bc
	jr	c,rf12		; branch if not
	out	(SER0+_THR),a	; else send char to transmitter FIFO
	inc	c
	djnz	rf11
rf12:	ld	a,c
	or	a		; anything sent?
	ret

oproc2:	iopage	SERP
	res	UM.OFP,(iy+UX.MOD) ; clear 'output fork process pending' flag
	bit	U2.XOF,(iy+UX.MOD+1)
	ret	nz		; return if XOFF bit is set
	call	refil2		; refill transmitter FIFO
	jp	z,chkend	; end output operation if nothing sent
	in	a,(SER1+_IER)
	set	1,a		; (re)enable TX interrupts
	out	(SER1+_IER),a
	ret

refil2:	ld	b,16
	ld	c,0
rf21:	push	bc
	call	nextch		; anything (else) to send?
	pop	bc
	jr	c,rf22		; branch if not
	out	(SER1+_THR),a	; else send char to transmitter FIFO
	inc	c
	djnz	rf21
rf22:	ld	a,c
	or	a		; anything sent?
	ret

oproc3:	iopage	SERP
	res	UM.OFP,(iy+UX.MOD) ; clear 'output fork process pending' flag
	bit	U2.XOF,(iy+UX.MOD+1)
	ret	nz		; return if XOFF bit is set
	call	refil3		; refill transmitter FIFO
	jp	z,chkend	; end output operation if nothing sent
	in	a,(SER2+_IER)
	set	1,a		; (re)enable TX interrupts
	out	(SER2+_IER),a
	ret

refil3:	ld	b,16
	ld	c,0
rf31:	push	bc
	call	nextch		; anything (else) to send?
	pop	bc
	jr	c,rf32		; branch if not
	out	(SER2+_THR),a	; else send char to transmitter FIFO
	inc	c
	djnz	rf31
rf32:	ld	a,c
	or	a		; anything sent?
	ret

oproc4:	iopage	SERP
	res	UM.OFP,(iy+UX.MOD) ; clear 'output fork process pending' flag
	bit	U2.XOF,(iy+UX.MOD+1)
	ret	nz		; return if XOFF bit is set
	call	refil4		; refill transmitter FIFO
	jp	z,chkend	; end output operation if nothing sent
	in	a,(SER3+_IER)
	set	1,a		; (re)enable TX interrupts
	out	(SER3+_IER),a
	ret

refil4:	ld	b,16
	ld	c,0
rf41:	push	bc
	call	nextch		; anything (else) to send?
	pop	bc
	jr	c,rf42		; branch if not
	out	(SER3+_THR),a	; else send char to transmitter FIFO
	inc	c
	djnz	rf41
rf42:	ld	a,c
	or	a		; anything sent?
	ret

; TT1..4 get RX character

getc1:	iopage	SERP
	in	a,(SER0+_LSR)
	bit	0,a		; RX data available?
	jr	z,gc1		; branch if not
	in	a,(SER0+_RHR)	; fetch char
	or	a		; return success
	ret
gc1:	in	a,(SER0+_IER)
	set	0,a		; else (re)enable RX interrupts
	out	(SER0+_IER),a
	scf			; and return error
	ret

getc2:	iopage	SERP
	in	a,(SER1+_LSR)
	bit	0,a		; RX data available?
	jr	z,gc2		; branch if not
	in	a,(SER1+_RHR)	; fetch char
	or	a		; return success
	ret
gc2:	in	a,(SER1+_IER)
	set	0,a		; else (re)enable RX interrupts
	out	(SER1+_IER),a
	scf			; and return error
	ret

getc3:	iopage	SERP
	in	a,(SER2+_LSR)
	bit	0,a		; RX data available?
	jr	z,gc3		; branch if not
	in	a,(SER2+_RHR)	; fetch char
	or	a		; return success
	ret
gc3:	in	a,(SER2+_IER)
	set	0,a		; else (re)enable RX interrupts
	out	(SER2+_IER),a
	scf			; and return error
	ret

getc4:	iopage	SERP
	in	a,(SER3+_LSR)
	bit	0,a		; RX data available?
	jr	z,gc4		; branch if not
	in	a,(SER3+_RHR)	; fetch char
	or	a		; return success
	ret
gc4:	in	a,(SER3+_IER)
	set	0,a		; else (re)enable RX interrupts
	out	(SER3+_IER),a
	scf			; and return error
	ret

; TT1..4 check RX input queue, returns Z if queue is empty

chkrx1:	iopage	SERP
	in	a,(SER0+_LSR)
	and	00000001b
	ret

chkrx2:	iopage	SERP
	in	a,(SER1+_LSR)
	and	00000001b
	ret

chkrx3:	iopage	SERP
	in	a,(SER2+_LSR)
	and	00000001b
	ret

chkrx4:	iopage	SERP
	in	a,(SER3+_LSR)
	and	00000001b
	ret

; TT1..4 purge RX queue

clrx1:	iopage	SERP
	ld	a,00000011b	; flush RHR, enable FIFO, RX threshold level = 1
	out	(SER0+_FCR),a
	jp	gc1		; (re)enable RX ints

clrx2:	iopage	SERP
	ld	a,00000011b	; flush RHR, enable FIFO, RX threshold level = 1
	out	(SER1+_FCR),a
	jp	gc2		; (re)enable RX ints

clrx3:	iopage	SERP
	ld	a,00000011b	; flush RHR, enable FIFO, RX threshold level = 1
	out	(SER2+_FCR),a
	jp	gc3		; (re)enable RX ints

clrx4:	iopage	SERP
	ld	a,00000011b	; flush RHR, enable FIFO, RX threshold level = 1
	out	(SER3+_FCR),a
	jp	gc4		; (re)enable RX ints

;-----------------------------------------------------------------------

; TT1..TT4 interrupt handling routines.

; OX16C954 interrupts
; Interrupts are already disabled by the interrupt stub in common memory.
; AF, HL, DE, BC and the I/O page resgister also have been saved.

TTQINT:	push	ix
	push	iy
	iopage	SERP
	ld	iy,ucbt1
	in	a,(SER0+_ISR)
	bit	0,a		; interrupt pending?
	call	z,tt1int	; handle if yes
	ld	iy,ucbt2
	in	a,(SER1+_ISR)
	bit	0,a		; interrupt pending?
	call	z,tt2int	; handle if yes
	ld	iy,ucbt3
	in	a,(SER2+_ISR)
	bit	0,a		; interrupt pending?
	call	z,tt3int	; handle if yes
	ld	iy,ucbt4
	in	a,(SER3+_ISR)
	bit	0,a		; interrupt pending?
	call	z,tt4int	; handle if yes
	pop	iy
	pop	ix
	ret

tt1int:	in	a,(SER0+_LSR)
	bit	0,a		; RX data available?
	jr	z,tt1tx		; no, try transmitter
	in	a,(SER0+_IER)
	res	0,a		; disable further RX interrupts
	out	(SER0+_IER),a
	call	ifpq		; setup input fork process
	in	a,(SER0+_LSR)
tt1tx:	bit	5,a		; TX FIFO full?
	ret	z		; return if yes
	in	a,(SER0+_IER)
	res	1,a		; disable further TX interrupts
	out	(SER0+_IER),a
	jp	ofpq		; and schedule fork process to refill FIFO

tt2int:	in	a,(SER1+_LSR)
	bit	0,a		; RX data available?
	jr	z,tt2tx		; no, try transmitter
	in	a,(SER1+_IER)
	res	0,a		; disable further RX interrupts
	out	(SER1+_IER),a
	call	ifpq		; setup input fork process
	in	a,(SER1+_LSR)
tt2tx:	bit	5,a		; TX FIFO full?
	ret	z		; return if yes
	in	a,(SER1+_IER)
	res	1,a		; disable further TX interrupts
	out	(SER1+_IER),a
	jp	ofpq		; and schedule fork process to refill FIFO

tt3int:	in	a,(SER2+_LSR)
	bit	0,a		; RX data available?
	jr	z,tt3tx		; no, try transmitter
	in	a,(SER2+_IER)
	res	0,a		; disable further RX interrupts
	out	(SER2+_IER),a
	call	ifpq		; setup input fork process
	in	a,(SER2+_LSR)
tt3tx:	bit	5,a		; TX FIFO full?
	ret	z		; return if yes
	in	a,(SER2+_IER)
	res	1,a		; disable further TX interrupts
	out	(SER2+_IER),a
	jp	ofpq		; and schedule fork process to refill FIFO

tt4int:	in	a,(SER3+_LSR)
	bit	0,a		; RX data available?
	jr	z,tt4tx		; no, try transmitter
	in	a,(SER3+_IER)
	res	0,a		; disable further RX interrupts
	out	(SER3+_IER),a
	call	ifpq		; setup input fork process
	in	a,(SER3+_LSR)
tt4tx:	bit	5,a		; TX FIFO full?
	ret	z		; return if yes
	in	a,(SER3+_IER)
	res	1,a		; disable further TX interrupts
	out	(SER3+_IER),a
	jp	ofpq		; and schedule fork process to refill FIFO

;-----------------------------------------------------------------------
; Queue handling routines
;-----------------------------------------------------------------------

; Add char to queue. IX = queue, C = char. Returns CY if queue full.
; Modifies A and DE.

qput:	ld	a,(ix+TQ.IP)
	ld	e,a
	inc	a
	and	(ix+TQ.MSK)
	cp	(ix+TQ.OP)
	scf
	ret	z		; buffer full
	ld	(ix+TQ.IP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	(ix+TQ.BUF),c	; buf[ipos]
	pop	ix
	or	a
	ret

; Add a string of chars to queue. IX = queue, HL = string address,
; B = length

qstr:	ld	a,b
	or	a
	ret	z
qstr1:	ld	c,(hl)
	di
	call	qput
	ei
	inc	hl
	djnz	qstr1
	ret

; Get char from queue. IX = queue, returns A = char, or CY if queue empty.
; Modifies DE.

qget:	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	scf
	ret	z		; buffer empty
	ld	e,a
	inc	a
	and	(ix+TQ.MSK)
	ld	(ix+TQ.OP),a
	ld	d,0
	push	ix
	add	ix,de
	ld	a,(ix+TQ.BUF)	; buf[opos]
	pop	ix
	or	a
	ret

; Peek char from queue. IX = queue, returns A = char, or CY if queue empty.
; Modifies DE.

qpeek:	ld	a,(ix+TQ.OP)
	cp	(ix+TQ.IP)
	scf
	ret	z		; buffer empty
	ld	e,a
	ld	d,0
	push	ix
	add	ix,de
	ld	a,(ix+TQ.BUF)	; buf[opos]
	pop	ix
	or	a
	ret

; Init queue. IX = queue.

qinit:	xor	a
	ld	(ix+TQ.IP),a
	ld	(ix+TQ.OP),a
	ret

; Get number of bytes in queue. IX = queue, returns A = # of bytes.

qsize:	ld	a,(ix+TQ.OP)
	sub	(ix+TQ.IP)
	ret	nc		; size = opos - ipos
	ret	nz
	add	a,(ix+TQ.MSK)
	inc	a		; queue size = mask + 1
	ret

; IX = queue, returns Z if queue is empty

qempty:	ld	a,(ix+TQ.IP)
	sub	(ix+TQ.OP)
	or	a		; clear CY to avoid extraneous errors
	ret

; IX = queue, returns Z if queue is full

qfull:	ld	a,(ix+TQ.IP)
	inc	a
	and	(ix+TQ.MSK)
	sub	(ix+TQ.OP)
	or	a		; clear CY to avoid extraneous errors
	ret

; Get CLI prompt from CLICB. B=0 for default prompt, else ^C prompt.

; TODO: get the CLI associated to the terminal.

cliprm:	ld	de,($CLIST)	; get head of CLI list
	ld	a,d
	or	e		; CLI set?
	ld	hl,nulprm	; return null string if not
	ret	z
	ld	hl,CL.DPL
	add	hl,de
	ld	c,(hl)		; get length of default prompt
	ld	hl,CL.DAT
	add	hl,de		; point to start of strings
	inc	b
	dec	b
	ret	z		; this is the one we want
	ld	b,0
	add	hl,bc		; else return the second string
	ret

nulprm:	db	0

;-----------------------------------------------------------------------

	dseg

ttdcb:	ds	2		; terminal DCB address

; Terminal I/O queues

TTQ	MACRO	size
	IF	size AND (size-1)
	ERROR	Queue size must be a power of 2
	ENDIF
	IF	size LT 2
	ERROR	Queue size must be greater than 2
	ENDIF
	db	size-1		; mask
	ds	1		; ipos
	ds	1		; opos
	ds	size		; buf
	ENDM

tt0iq:	TTQ	32		; receiver queue
tt0tq:	TTQ	32		; typeahead queue
tt0oq:	TTQ	32		; output queue
tt0xq:	TTQ	32		; transmitter queue

tt1tq:	TTQ	128		; typeahead queue
tt1oq:	TTQ	32		; output queue

tt2tq:	TTQ	128		; typeahead queue
tt2oq:	TTQ	32		; output queue

tt3tq:	TTQ	128		; typeahead queue
tt3oq:	TTQ	32		; output queue

tt4tq:	TTQ	128		; typeahead queue
tt4oq:	TTQ	32		; output queue

	END
